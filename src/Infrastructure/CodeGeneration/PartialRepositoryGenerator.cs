using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace NextAdmin.Infrastructure.CodeGeneration
{
    /// <summary>
    /// Partial repository code generator
    /// Automatically generates base implementation code based on repository interfaces
    /// </summary>
    public class PartialRepositoryGenerator
    {
        private readonly string _outputDirectory;
        private readonly Assembly[] _assemblies;

        public PartialRepositoryGenerator(string outputDirectory, params Assembly[] assemblies)
        {
            _outputDirectory = outputDirectory ?? throw new ArgumentNullException(nameof(outputDirectory));
            _assemblies = assemblies ?? Array.Empty<Assembly>();
        }

        /// <summary>
        /// Generate partial implementations for all repositories
        /// </summary>
        public async Task GenerateAllRepositoriesAsync()
        {
            Console.WriteLine("=== Partial Repository Code Generator ===");
            Console.WriteLine($"Output directory: {_outputDirectory}");
            Console.WriteLine();

            if (!Directory.Exists(_outputDirectory))
            {
                Directory.CreateDirectory(_outputDirectory);
                Console.WriteLine($"‚úÖ Output directory created");
            }

            // Find all repository interfaces
            var repositoryInterfaces = FindRepositoryInterfaces();
            Console.WriteLine($"üìã Found {repositoryInterfaces.Count} repository interfaces");
            Console.WriteLine();

            foreach (var interfaceType in repositoryInterfaces)
            {
                await GeneratePartialRepositoryAsync(interfaceType);
            }

            Console.WriteLine();
            Console.WriteLine("üéâ All repository code generation completed!");
        }

        /// <summary>
        /// Generate partial implementation for a single repository
        /// </summary>
        public async Task GeneratePartialRepositoryAsync(Type interfaceType)
        {
            if (interfaceType == null || !interfaceType.IsInterface)
            {
                throw new ArgumentException("Must be an interface type", nameof(interfaceType));
            }

            var entityName = GetEntityNameFromInterface(interfaceType);
            var fileName = $"{entityName}Repository.Generated.cs";
            var filePath = Path.Combine(_outputDirectory, fileName);

            Console.WriteLine($"üîß Generating: {fileName}");

            var code = GenerateRepositoryCode(interfaceType, entityName);

            await File.WriteAllTextAsync(filePath, code, Encoding.UTF8);

            Console.WriteLine($"   ‚úÖ Generated: {filePath}");
        }

        /// <summary>
        /// Find all repository interfaces
        /// </summary>
        private List<Type> FindRepositoryInterfaces()
        {
            var interfaces = new List<Type>();

            foreach (var assembly in _assemblies)
            {
                try
                {
                    var types = assembly.GetTypes()
                        .Where(t => t.IsInterface &&
                                    t.Name.StartsWith("I") &&
                                    t.Name.EndsWith("Repository") &&
                                    t.Name != "IBaseRepository")
                        .ToList();

                    interfaces.AddRange(types);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"‚ö†Ô∏è  Warning: Unable to load assembly {assembly.FullName}: {ex.Message}");
                }
            }

            return interfaces;
        }

        /// <summary>
        /// Extract entity name from interface name
        /// </summary>
        private string GetEntityNameFromInterface(Type interfaceType)
        {
            var name = interfaceType.Name;
            if (name.StartsWith("I") && name.EndsWith("Repository"))
            {
                return name.Substring(1, name.Length - 11); // Remove "I" and "Repository"
            }
            return name;
        }

        /// <summary>
        /// Generate repository code
        /// </summary>
        private string GenerateRepositoryCode(Type interfaceType, string entityName)
        {
            var sb = new StringBuilder();

            // File header comment
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// This file was automatically generated by PartialRepositoryGenerator");
            sb.AppendLine($"// Generation time: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine("// Warning: Do not manually modify this file, your changes will be lost on next generation");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();

            // Using declarations
            var usings = GetRequiredUsings(interfaceType);
            foreach (var usingNamespace in usings.OrderBy(u => u))
            {
                sb.AppendLine($"using {usingNamespace};");
            }
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {interfaceType.Namespace?.Replace(".Interfaces.Repositories", ".Repositories") ?? "NextAdmin.Infrastructure.Repositories"}");
            sb.AppendLine("{");

            // Class declaration
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Auto-generated implementation for {entityName} repository");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine($"    public partial class {entityName}Repository");
            sb.AppendLine("    {");

            // Generate method implementations
            var methods = GetCustomMethods(interfaceType);
            var isFirst = true;

            foreach (var method in methods)
            {
                if (!isFirst)
                {
                    sb.AppendLine();
                }
                isFirst = false;

                GenerateMethodImplementation(sb, method, entityName);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Get required using declarations
        /// </summary>
        private HashSet<string> GetRequiredUsings(Type interfaceType)
        {
            var usings = new HashSet<string>
            {
                "System",
                "System.Collections.Generic",
                "System.Linq",
                "System.Threading.Tasks",
                "MongoDB.Driver",
                "MongoDB.Bson"
            };

            // Add interface namespace
            if (!string.IsNullOrEmpty(interfaceType.Namespace))
            {
                usings.Add(interfaceType.Namespace);
            }

            // Analyze method parameter and return types
            var methods = interfaceType.GetMethods();
            foreach (var method in methods)
            {
                // Return typern type
                if (!string.IsNullOrEmpty(method.ReturnType.Namespace))
                {
                    usings.Add(method.ReturnType.Namespace);
                }

                // Parameter types
                foreach (var parameter in method.GetParameters())
                {
                    if (!string.IsNullOrEmpty(parameter.ParameterType.Namespace))
                    {
                        usings.Add(parameter.ParameterType.Namespace);
                    }
                }
            }

            return usings;
        }

        /// <summary>
        /// Get custom methods in the interface (excluding IBaseRepository methods)
        /// </summary>
        private List<MethodInfo> GetCustomMethods(Type interfaceType)
        {
            var allMethods = interfaceType.GetMethods();
            
            // Exclude standard methods from IBaseRepository<T>
            var standardMethodNames = new HashSet<string>
            {
                "GetByIdAsync", "GetAllAsync", "AddAsync", "UpdateAsync", 
                "DeleteAsync", "ExistsAsync", "CountAsync", "GetPagedAsync",
                "BulkAddAsync", "BulkUpdateAsync", "BulkDeleteAsync"
            };

            return allMethods
                .Where(m => !standardMethodNames.Contains(m.Name))
                .ToList();
        }

        /// <summary>
        /// Generate method implementation
        /// </summary>
        private void GenerateMethodImplementation(StringBuilder sb, MethodInfo method, string entityName)
        {
            // XML documentation
            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// Auto-generated implementation for {method.Name}");
            sb.AppendLine("        /// </summary>");

            // Method signature
            var parameters = method.GetParameters();
            var paramList = string.Join(", ", parameters.Select(p => $"{GetFriendlyTypeName(p.ParameterType)} {p.Name}"));
            var returnType = GetFriendlyTypeName(method.ReturnType);

            sb.AppendLine($"        public {returnType} {method.Name}({paramList})");
            sb.AppendLine("        {");

            // Generate method body
            GenerateMethodBody(sb, method, entityName);

            sb.AppendLine("        }");
        }

        /// <summary>
        /// Generate method body
        /// </summary>
        private void GenerateMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            var returnType = method.ReturnType;
            var isAsync = returnType.Name.Contains("Task");

            // Infer implementation logic based on method name
            var methodName = method.Name;

            if (methodName.StartsWith("GetBy") && methodName.EndsWith("Async"))
            {
                GenerateGetByMethodBody(sb, method, entityName);
            }
            else if (methodName.StartsWith("Search") && methodName.EndsWith("Async"))
            {
                GenerateSearchMethodBody(sb, method, entityName);
            }
            else if (methodName.StartsWith("Exists") && methodName.EndsWith("Async"))
            {
                GenerateExistsMethodBody(sb, method, entityName);
            }
            else if (methodName.StartsWith("GetCount") || methodName.Contains("Count"))
            {
                GenerateCountMethodBody(sb, method, entityName);
            }
            else if (methodName.StartsWith("BulkInsert") || methodName.StartsWith("Bulk"))
            {
                GenerateBulkMethodBody(sb, method, entityName);
            }
            else
            {
                // Default implementation: throw NotImplementedException
                sb.AppendLine($"            throw new NotImplementedException(\"Method {method.Name} needs to be implemented in another partial part of {entityName}Repository.\");");
            }
        }

        /// <summary>
        /// Generate GetBy method body
        /// </summary>
        private void GenerateGetByMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            var parameters = method.GetParameters();
            var returnType = method.ReturnType;
            var isList = returnType.IsGenericType && returnType.GetGenericTypeDefinition() == typeof(Task<>)
                && returnType.GetGenericArguments()[0].IsGenericType
                && returnType.GetGenericArguments()[0].GetGenericTypeDefinition() == typeof(List<>);

            sb.AppendLine("            var filterBuilder = Builders<" + entityName + ">.Filter;");
            sb.AppendLine("            var filters = new List<FilterDefinition<" + entityName + ">>");
            sb.AppendLine("            {");
            sb.AppendLine("                filterBuilder.Eq(x => x.IsDeleted, false)");
            sb.AppendLine("            };");
            sb.AppendLine();

            // Add filter condition for each parameter
            foreach (var param in parameters)
            {
                var paramName = param.Name;
                var propertyName = char.ToUpper(paramName![0]) + paramName.Substring(1);

                if (param.ParameterType.Name.Contains("Nullable") || param.ParameterType.IsClass)
                {
                    sb.AppendLine($"            if ({paramName} != null)");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                filters.Add(filterBuilder.Eq(x => x.{propertyName}, {paramName}));");
                    sb.AppendLine("            }");
                }
                else
                {
                    sb.AppendLine($"            filters.Add(filterBuilder.Eq(x => x.{propertyName}, {paramName}));");
                }
            }

            sb.AppendLine();
            sb.AppendLine("            var filter = filterBuilder.And(filters);");
            sb.AppendLine();

            if (isList)
            {
                sb.AppendLine("            return await Collection.Find(filter)");
                sb.AppendLine("                .SortBy(x => x.CreateTime)");
                sb.AppendLine("                .ToListAsync();");
            }
            else
            {
                sb.AppendLine("            return await Collection.Find(filter).FirstOrDefaultAsync();");
            }
        }

        /// <summary>
        /// Generate Search method body
        /// </summary>
        private void GenerateSearchMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            sb.AppendLine("            // TODO: Implement search logic");
            sb.AppendLine("            var filter = Builders<" + entityName + ">.Filter.Eq(x => x.IsDeleted, false);");
            sb.AppendLine("            return await Collection.Find(filter).ToListAsync();");
        }

        /// <summary>
        /// Generate Exists method body
        /// </summary>
        private void GenerateExistsMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            sb.AppendLine("            var filter = Builders<" + entityName + ">.Filter.Eq(x => x.IsDeleted, false);");
            sb.AppendLine("            var count = await Collection.CountDocumentsAsync(filter);");
            sb.AppendLine("            return count > 0;");
        }

        /// <summary>
        /// Generate Count method body
        /// </summary>
        private void GenerateCountMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            sb.AppendLine("            var filter = Builders<" + entityName + ">.Filter.Eq(x => x.IsDeleted, false);");
            sb.AppendLine("            return await Collection.CountDocumentsAsync(filter);");
        }

        /// <summary>
        /// Generate Bulk method body
        /// </summary>
        private void GenerateBulkMethodBody(StringBuilder sb, MethodInfo method, string entityName)
        {
            sb.AppendLine("            // TODO: Implement bulk operation logic");
            sb.AppendLine($"            throw new NotImplementedException(\"Method {method.Name} needs to be implemented in another partial part of {entityName}Repository.\");");
        }

        /// <summary>
        /// Get friendly type name
        /// </summary>
        private string GetFriendlyTypeName(Type type)
        {
            if (!type.IsGenericType)
            {
                return type.Name switch
                {
                    "Void" => "void",
                    "String" => "string",
                    "Int32" => "int",
                    "Int64" => "long",
                    "Boolean" => "bool",
                    "Double" => "double",
                    "Decimal" => "decimal",
                    _ => type.Name
                };
            }

            var genericTypeName = type.Name.Split('`')[0];
            var genericArgs = string.Join(", ", type.GetGenericArguments().Select(GetFriendlyTypeName));

            return $"{genericTypeName}<{genericArgs}>";
        }
    }
}
